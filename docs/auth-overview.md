# Регистрация, авторизация и аутентификация (JWT + GitHub)

## Компоненты
- **UMS**: центр регистрации/логина и выпуска JWT.
- **Twitter**: защищенный API (resource server); валидирует токены через интроспекцию UMS.
- **Frontend**: получает JWT и передает `Authorization: Bearer <token>` в запросах.

## Ключевая идея
Каждый пользователь имеет собственный секрет `secret_key` в БД. JWT подписывается **индивидуальным HMAC‑ключом пользователя (HS256)**.  
При валидации токена UMS достает `secret_key` по `sub` (userId) и проверяет подпись.  
Сброс `secret_key` моментально инвалидирует все ранее выданные токены.

## Хранилище
- Таблица `users` содержит:
  - `password` (BCrypt; старые plain‑text пароли автоматически апгрейдятся при логине)
  - `secret_key` (HEX, 64 символа, генерируется из 32 random bytes)
- Таблица `user_identities` хранит привязки к OAuth‑провайдерам (GitHub).

## Потоки
### 1) Регистрация
1. Клиент вызывает `POST /auth/register`.
2. UMS создает пользователя, генерирует `secret_key`.
3. UMS выдает JWT, подписанный `secret_key` пользователя.

### 2) Логин
1. Клиент вызывает `POST /auth/login`.
2. UMS проверяет пароль (BCrypt, либо миграция с plain‑text).
3. UMS выдает JWT, подписанный `secret_key` пользователя.

### 3) GitHub OAuth
1. Клиент идет на `/oauth2/authorization/github`.
2. После callback UMS создает/находит пользователя и привязывает GitHub identity.
3. UMS выдает JWT, подписанный `secret_key` пользователя.

### 4) Ротация секрета
1. Клиент вызывает `POST /auth/rotate-secret` с действующим JWT.
2. UMS меняет `secret_key` и выдает новый JWT.
3. Все старые токены становятся невалидны.

### 5) Валидация токена
**UMS**:
- парсит JWT,
- берет `sub`,
- загружает `secret_key`,
- проверяет подпись HS256,
- проверяет `iss`, `exp`, `iat`.

**Twitter**:
- сам подпись не проверяет (не имеет ключа),
- вызывает `POST /auth/introspect` в UMS,
- принимает запрос только если `active=true`.

## Настройки
- `GITHUB_CLIENT_ID`, `GITHUB_CLIENT_SECRET`, `GITHUB_REDIRECT_URI`
- `app.jwt.issuer`, `app.jwt.ttl-seconds`

## Почему это безопасно
Компрометация одного JWT не раскрывает секреты других пользователей.  
Ротация `secret_key` позволяет быстро отозвать токены конкретного пользователя.
